#ifndef FILE_UTIL_H
#define FILE_UTIL_H

#include <string>
#include <cstdlib>
#include <fstream> // Include this header for std::ifstream
#include <ngin/debug/logger.h>
#include <root_directory.h> // This is a configuration file generated by CMake.

#include <tuple>

class FileUtil {
private:
    typedef std::string (*Builder) (const std::string& path);
    static inline ngin::debug::Logger* logger_ = new ngin::debug::Logger("File");

public:
    static inline const std::string ASSETS_PREFIX = "assets/";
    static inline const std::string RESOURCES_PREFIX = "resources/";

    // exist functions
    static bool does_path_exist(const std::string& path) {
        std::ifstream file(path);
        return file.good();
    }

    static std::string get_root_path(const std::string& path) {
        static std::string(*path_builder)(std::string const &) = get_root_path_builder();
        return (*path_builder)(path);
    }
    static std::string get_project_path(const std::string& path) {
        static std::string(*proj_path_builder)(std::string const &) = get_proj_path_builder();
        return (*proj_path_builder)(path);
    }


    // asset functions:
    static std::tuple<std::string, bool> get_generic_asset_path(const std::string& path) {
        std::tuple<std::string, bool> asset_result = get_asset_path(path);
        if (std::get<1>(asset_result)) {
            return asset_result;
        }
        std::tuple<std::string, bool> resource_result = get_resource_path(path);
        if (std::get<1>(resource_result)) {
            return resource_result;
        }
        return std::make_tuple("", false);
    }
    static std::tuple<std::string, bool> get_asset_path(const std::string& path) {
        size_t pos = path.find(ASSETS_PREFIX);
        std::string clean_path = (pos != std::string::npos) ? path.substr(pos + 10) : path;
        std::string asset_path = get_root_path(ASSETS_PREFIX + clean_path);
        std::string asset_path_alt = get_project_path(ASSETS_PREFIX + clean_path);
        if (does_path_exist(asset_path)) {
            return std::make_tuple(asset_path, true);
        } else if (does_path_exist(asset_path_alt)) {
            return std::make_tuple(asset_path_alt, true);
        } else {
            return std::make_tuple("", false);
        }
    }
    static std::tuple<std::string, bool> get_resource_path(const std::string& path) {
        size_t pos = path.find(RESOURCES_PREFIX);
        std::string clean_path = (pos != std::string::npos) ? path.substr(pos + 10) : path;
        std::string resource_path = get_root_path(RESOURCES_PREFIX + clean_path);
        std::string resource_path_alt = get_project_path(RESOURCES_PREFIX + clean_path);
        if (does_path_exist(resource_path)) {
            return std::make_tuple(resource_path, true);
        } else if (does_path_exist(resource_path_alt)) {
            return std::make_tuple(resource_path_alt, true);
        } else {
            return std::make_tuple("", false);
        }
    }
    static bool does_asset_exist(const std::string& path) {
        std::tuple<std::string, bool> asset_result = get_asset_path(path);
        return std::get<1>(asset_result);
    }
    static bool does_resource_exist(const std::string& path) {
        std::tuple<std::string, bool> resource_result = get_resource_path(path);
        return std::get<1>(resource_result);
    }
     
private:
    static std::string const & get_root_dir() {
        static char const * env_root = getenv("LOGL_ROOT_PATH");
        static char const * given_root = (env_root != nullptr ? env_root : ROOT_DIR);
        static std::string root = (given_root != nullptr ? given_root : "");
        return root;
    }
    static std::string const & get_project_dir() {
        static char const * eng_proj_dir = getenv("LOGL_PROJ_PATH"); // Assuming this is the environment variable for PROJ_DIR
        static char const * given_proj_dir = (eng_proj_dir != nullptr ? eng_proj_dir : PROJ_DIR); // Assuming PROJ_DIR is defined in the CMake configuration
        static std::string proj_dir = (given_proj_dir != nullptr ? given_proj_dir : "");
        return proj_dir;
    }

    static Builder get_root_path_builder() {
        if (get_root_dir() != "")
            return &FileUtil::get_path_relative_root;
        else
            return &FileUtil::get_path_relative_binary;
    }
    static Builder get_proj_path_builder() {
        if (get_project_dir() != "")
            return &FileUtil::get_path_relative_project;
        else
            return &FileUtil::get_path_relative_binary; // Fallback if PROJ_DIR is not available
    }

    static std::string get_path_relative_root(const std::string& path) {
        return get_root_dir() + std::string("/") + path;
    }
    static std::string get_path_relative_project(const std::string& path) {
        return get_project_dir() + std::string("/") + path;
    }
    static std::string get_path_relative_binary(const std::string& path) {
        return "../../../" + path;
    }
};

#endif // FILE_UTIL_H